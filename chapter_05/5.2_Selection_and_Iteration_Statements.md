# Chapter 5: Expressions, Statements, and Control Flow  
[Table of Contents](../README.md)
## 5.2: Selection and Iteration Statements in Modern C++

**Selection** and **iteration** statements form the backbone of control flow in C++. Mastery of these constructs is essential both for clear, robust application logic and for modern code quality. This section covers traditional and modern forms, best practices, common pitfalls, and leverages features up through C++23, with practical advice for real-world scenarios.

---

## 1. Introduction: What and Why

**Selection statements** control the execution path based on conditions (e.g., `if`, `switch`).  
**Iteration statements** repeat code blocks based on conditions or data (e.g., `while`, `for`, range-based `for`, `do-while`).

**Good control flow achieves:**
- Code clarity and intent
- Safe resource management
- Expressive and maintainable logic

---

## 2. Selection Statements

### 2.1 `if`, `else if`, and `else`

**Syntax:**
```cpp
if (condition) {
    // true path
} else if (other_condition) {
    // optional: alternative path
} else {
    // optional: fallback
}
```
**Key Concepts:**
- The **condition** is an expression convertible to `bool`. Use direct boolean checks, avoid implicit conversions from pointers or integers for clarity and correctness.
- Since C++17, multiple variable declaration and structured bindings are allowed within the condition (see below).

**Best Practices:**
- Limit the scope of condition-specific variables using the C++17 initialization statement syntax:
    ```cpp
    if (auto it = my_map.find(key); it != my_map.end()) {
        process(*it);
    }
    ```
- Prefer **early returns** over deeply nested `if`/`else` blocks.
- For constant conditions, use `if constexpr` (C++17) for compile-time selection, not run-time.

### 2.2 `switch` Statement

```cpp
switch (expression) {
    case value1:
        // ...
        break;
    case value2:
        // ...
        break;
    default:
        // ...
}
```

**Details:**
- Evaluates `expression`, jumps to the matching `case`.
- Use `enum class` for type-safe switch expressions.
- `break` prevents fall through; omitting it intentionally is rare and must be explicit (as of C++17, attribute `[[fallthrough]]`).

**Modern Best Practices:**
- Use `[[fallthrough]];` to document intentional fallthrough—required for clarity and to suppress compiler warnings.
    ```cpp
    switch (event.type) {
        case EventType::Start:
            do_start();
            [[fallthrough]];
        case EventType::Continue:
            do_continue();
            break;
        case EventType::Stop:
            do_stop();
            break;
        default:
            handle_unknown();
    }
    ```
- Avoid default fallthrough, which is error-prone and hard to maintain.
- Group related cases when possible.

**C++23:**
- Pattern matching switches anticipated in future standards, but not present yet. Track ongoing proposals.

**Real-world Example:**  
Using `enum class` to switch safely (prevents accidental mixing of unrelated scoped enums):

```cpp
enum class LogLevel { Info, Warning, Error };
void log(LogLevel level, std::string_view msg) {
    switch (level) {
    case LogLevel::Info: std::cout << "INFO: "; break;
    case LogLevel::Warning: std::cout << "WARNING: "; break;
    case LogLevel::Error: std::cout << "ERROR: "; break;
    }
    std::cout << msg << '\n';
}
```

---

## 3. Iteration Statements

Modern C++ offers several powerful mechanisms for repetition and traversal, each with best uses.

### 3.1 Traditional Loops: `while`, `do-while`, `for`

**`while` Loop:**
```cpp
while (condition) {
    // runs as long as condition is true
}
```
- Use when the number of iterations isn't known ahead of time.

**`do-while` Loop:**
```cpp
do {
    // runs at least once
} while (condition);
```

**Classic `for` Loop:**
```cpp
for (int i = 0; i < n; ++i) {
    process(i);
}
```
- Use when counting is explicit or when you must manipulate the loop index.

**Best Practices:**
- Avoid off-by-one errors by using `<` for limits and range-based for-loops whenever possible.
- Prefer `const` for loop variables unless mutation is needed.
- Minimize variable scope—declare counters inside the loop.

### 3.2 Range-Based `for` Loop (C++11 and Later)

Suited for containers and arrays, this idiomatic C++ tool makes your intentions clearer and code safer.

```cpp
std::vector<int> v{1, 2, 3};
for (int x : v) {
    std::cout << x << ' ';
}
```

**How it Works:**
- Iterates over every element in `v`.
- Can (and usually should) use references or `const` to avoid copies.

```cpp
for (const auto& item : my_container) { /* ... */ }
```

**Modern Patterns:**
- Use `auto` to avoid verbosity.
- Prefer structured bindings (C++17) for iterating over map pairs or tuple-like ranges:

```cpp
std::map<std::string, int> ages;
for (const auto& [name, age] : ages) {
    std::cout << name << " is " << age << " years old\n";
}
```

### 3.3 More Modern Iteration: Ranges and Views (C++20–C++23)

The **ranges library** (C++20+) adds composability and lazy, efficient transformations:

```cpp
#include <ranges>
#include <vector>
#include <iostream>
void demo() {
    std::vector<int> values = {1, 2, 3, 4, 5};
    auto evens = values | std::views::filter([](int x){ return x % 2 == 0; });
    for (int v : evens) {
        std::cout << v << ' '; // prints 2 4
    }
}
```

**Key Features:**
- Pipe syntax for combining multiple transformations.
- Views are lazy—elements are only processed as needed.

**When to Use:**
- For readable, efficient processing pipelines.
- When dealing with large containers or costly transformations.

---

## 4. Best Practices and Pitfalls

- **Avoid magic numbers:** Use named constants for limits or keys.
- **Avoid modifying loop containers inside range-based loops:** This can cause undefined behavior.
- **Minimize variable scope:** Declare loop variables inside control statements when possible.
    ```cpp
    for (auto i = 0; i < N; ++i) { ... }
    ```
- **Edge Cases:** Ensure proper loop exit conditions to avoid infinite loops.
- **Use standard algorithms like `std::for_each` when the logic is simple or already encapsulated.**
- **Do not rely on loop variable value outside the loop:** The variable's scope should match its use for clarity.

---

## 5. Modern Patterns and Advanced Topics

### 5.1 `if` with Initialization Statement (C++17)

Improves scoping and prevents variable leakage:
```cpp
if (auto it = dict.find(key); it != dict.end()) {
    use(*it);
}
```

### 5.2 `constexpr if` (C++17)

Used in templates and metaprogramming—chooses a branch at compile-time if the condition is a constant expression.

```cpp
template<typename T>
void process(const T& x) {
    if constexpr (std::is_integral_v<T>) {
        // compile-time only for integral types
    } else {
        // otherwise
    }
}
```

### 5.3 Range-Based Loops with Structured Bindings (C++17)

Cleanly unpack elements:
```cpp
for (const auto& [k, v] : my_map) { ... }
```

### 5.4 Idiomatic Loop Termination

Use modern idioms to determine the end of containers:
```cpp
for (auto it = c.begin(); it != c.end(); ++it) { ... } // classic
for (const auto& x : c) { ... } // modern preferred
```

---

## 6. Performance and Readability

- **Prefer range-based loops** when iterating over entire containers for clarity and safety.
- **Classic index-based for-loops** may be needed for performance-sensitive sections, but always ask: am I optimizing prematurely, and is the operation cache- or bounds-sensitive?
- **Modern compilers** will often optimize range-based loops as efficiently as index-based loops, especially when inlining is likely.

---

## 7. Real-World Example: Efficient Filtering

Suppose you need to process only even numbers in a vector.

**Old approach:**
```cpp
for (size_t i = 0; i < v.size(); ++i) {
    if (v[i] % 2 == 0) process(v[i]);
}
```

**Modern approach with ranges (C++20):**
```cpp
for (int x : v | std::views::filter([](int i) { return i % 2 == 0; })) {
    process(x);
}
```
Easier to read, pipelines logic, and avoids manual bookkeeping.

---

## 8. Summary Table: Selection and Iteration in Modern C++

| Feature              | Modern Best Practice           | Notes                                                             |
|----------------------|-------------------------------|-------------------------------------------------------------------|
| if/else              | Use scoping init-statements   | Reduces variable scope, safer                                     |
| switch               | Use enum class, [[fallthrough]] | Improves safety, documents logic                                  |
| for                  | Prefer range-based for         | Avoids off-by-one, clearer intent                                 |
| while/do-while       | Use when count isn't knowable | For state machines, user input loops, etc.                        |
| Ranges (C++20+)      | Use for composing transforms  | Efficient, lazy; great for filtering, mapping, chaining operations|
| Structured bindings  | Use in range-for and switch   | Cleaner unpacking for pairs/tuples etc.                           |

---

## 9. References and Further Reading

- **C++ Core Guidelines**, especially ES.10 and related control flow items[1].
- **Google C++ Style Guide** for organizational norms and practices[5].
- [cppreference.com](https://en.cppreference.com/) for up-to-date standard library and syntax changes.
- Jason Turner's _C++ Weekly_, especially episodes covering range-based for, switch, pitfalls, and C++17-20 features.

---

Mastering selection and iteration with a modern approach will immediately improve readability, safety, and maintainability of your C++ code, making you a more effective and professional C++ developer.