# Chapter 5: Expressions, Statements, and Control Flow  
[Table of Contents](../README.md)
## 5.4: Pattern Matching in Modern C++:  
## `if constexpr` (C++17+) and `if consteval` (C++23)

Understanding and efficiently utilizing *pattern matching* techniques—especially with the modern tools provided by `if constexpr` and `if consteval`—is essential for writing expressive, performant, and correct C++ code. This section will guide you through these features, explaining their foundations, usage patterns, and real-world implications, empowering you to write code that is both robust and maintainable.

---

## Why Pattern Matching and Compile-Time Control Flow Matter

Traditional C++ often relies on runtime control flow (`if`, `switch`) for branch selection. However, the evolution of C++ has introduced powerful mechanisms for selecting code branches at **compile time**, enabling:
- More efficient binaries (unused branches eliminated)
- Increased type safety through early error detection
- More expressive metaprogramming and generic code
- Cleaner and easier-to-read templates
- Safer function overloads and customizable behaviors

---

## 1. `if constexpr`: Compile-Time Conditional Expressions

Introduced in **C++17**, `if constexpr` allows writing *conditional code* that is evaluated during compilation. If the condition is **false** at compile time, the associated branch is not even instantiated—eliminating related errors and overhead.

#### Core Rules and Concepts

- **Condition:** Must be a constant expression; it’s evaluated at compile time.
- **Non-Selected Branch:** Must still be syntactically valid but is not instantiated, so errors within that branch don’t produce compilation errors (as long as they're not in the instantiated code path).
- Typically used in templates and generic code.

#### Syntax Example

```cpp
template <typename T>
void print_type_info(const T& x) {
    if constexpr (std::is_integral_v<T>) {
        std::cout << "Integral: " << x << '\n';
    } else if constexpr (std::is_floating_point_v<T>) {
        std::cout << "Floating point: " << x << '\n';
    } else {
        std::cout << "Other type\n";
    }
}
```
- Calling `print_type_info(42)` prints "Integral".
- Calling `print_type_info(3.14)` prints "Floating point".
- Only the code relevant to the chosen branch is instantiated; the rest does not contribute to compile-time errors.

#### Technical Details

- Within a template, `if constexpr` enables “pattern matching” on types, traits, or other constexpr logic.
- Compiler guarantees that only the selected branch is instantiated, allowing use of functions/types/expressions only valid for certain patterns.

#### Real-World Example: Customizing Functionality by Type

```cpp
template <typename T>
void process(T& x) {
    if constexpr (requires { x.foo(); }) {
        x.foo();
    } else {
        // Do nothing or handle alternative
        std::cout << "No foo() member function\n";
    }
}
// For objects with `foo()`, calls it; for those without, prints message.
```

---

## 2. Advanced Usage Patterns

### a. Type Traits

The C++ Standard Library provides **type traits** (in `<type_traits>`) for compile-time type information. These commonly drive `if constexpr` branches:

```cpp
template <typename T>
void process_value(const T& value) {
    if constexpr (std::is_pointer_v<T>) {
        std::cout << "Pointer points to " << *value << '\n';
    } else {
        std::cout << "Value: " << value << '\n';
    }
}
```

### b. Variadic Templates

With `if constexpr`, writing recursive variadic functions becomes safer and easier.

```cpp
template <typename... Args>
void print_all(const Args&... args) {
    ((std::cout << args << " "), ...);  // Fold expression (C++17+)
}
```

For more complex patterns:

```cpp
template <typename T, typename... Rest>
void process_args(const T& first, const Rest&... rest) {
    if constexpr (sizeof...(rest) == 0) {
        std::cout << "Last argument: " << first << '\n';
    } else {
        std::cout << "Argument: " << first << '\n';
        process_args(rest...);
    }
}
```

---

## 3. `if consteval`: Forcing Compile-Time Evaluation (C++23)

While `if constexpr` selects *which code is instantiated at compile time*, **`if consteval`** (C++23) checks *whether code is being executed in a constant evaluation context*—that is, whether the function's evaluation is occurring at compile time.

#### Use Cases

- Writing functions that can behave differently if called at compile time vs. run time.
- Ensuring compile-time safety in library code (e.g., metaprogramming or constexpr-based assertions).

#### Syntax and Example

```cpp
constexpr int foo(int x) {
    if consteval {
        // Only happens during compile-time evaluation
        return x * 2;
    } else {
        // Only happens in run-time evaluation
        return x + 2;
    }
}

constexpr int y = foo(3);  // y == 6 (compiled in constant expression context)
int z = foo(3);            // z == 5 (run time)
```

#### Common Use Patterns

- Prefer compile-time algorithms (faster, safer) by enforcing `if consteval`.
- Fall back to slower or less strict logic only when necessary at run time.

---

## 4. Practical Pattern Matching for Modern C++

Pattern matching in C++ is less formal than in some languages (like Rust or Haskell), but these constructs allow you to:

- **Dispatch logic based on types or compile-time values**: Essential for generic libraries, type-safe APIs, and efficient, reusable components.
- **Write safer metaprograms:** Errors only occur in the actually-used branches, removing pain from SFINAE-heavy legacy code.
- **Enable customization points:** Generic algorithms that auto-specialize their behavior (e.g., memory allocation, serialization, customization for user types).

#### Example: Type-based Behavior

```cpp
template <typename T>
constexpr auto get_name() {
    if constexpr (std::is_same_v<T, int>) return "int";
    else if constexpr (std::is_same_v<T, double>) return "double";
    else return "unknown";
}

std::cout << get_name<int>() << '\n';  // Outputs: int
```

#### Example: Constexpr Assertions

```cpp
constexpr int factorial(int n) {
    if consteval {
        // Extra assert or log only at compile time
        if (n < 0) throw std::invalid_argument("Negative");
    }
    return n <= 1 ? 1 : n * factorial(n - 1);
}
```
This ensures errors are visible immediately for `constexpr` uses, while deferring to runtime if called in a non-constexpr context.

---

## 5. Best Practices and Pitfalls

- **Always prefer `if constexpr` for compile-time type-based patterns.** Avoid SFINAE/private hacks where `if constexpr` can be used.
- **Write branches to be as self-contained and independent as possible.** Avoid sharing code that depends on different requirements in different branches.
- **For hard errors in compile-time code, use `static_assert` within `if constexpr` or `if consteval` blocks.**
- **Use `if consteval` only when the function is meaningfully different at compile time.** Don’t use it excessively; unnecessary complexity harms readability.

---

## 6. Related: Towards “Match” Expressions

Although not yet natively available (pattern matching `match` is proposed for future C++), using `if constexpr`, modern templates, and overloading allows you to approximate expressive, pattern-matching-like code.

*See advanced resources and library implementations that attempt to provide “match” patterns for algebraic types or variants, such as Boost.Hana, Mach7, or std::visit for `std::variant`.*

---

## Conclusion: Master Pattern Matching for Modern, Robust Code

Leveraging `if constexpr` and `if consteval` enables expressive, efficient, and safe code. These tools are essential for any C++ developer working with generic programming, libraries, performance-critical code, or advanced metaprogramming. Master these concepts to produce code that:
- Is more readable and maintainable
- Has fewer template-related bugs
- Performs optimally, with compile-time guarantees

---

**Further Exploration:**
- Explore `std::variant` and `std::visit` for algebraic "sum-type" polymorphism.
- Learn type traits, and *concepts* (C++20) for more expressive constraints.
- Follow best practices from books such as *Template Metaprogramming with C++* (Marius Bancila)[2], *Modern C++ Design* (Andrei Alexandrescu)[3].

---

**Key Takeaway:**  
Pattern matching in C++ is not a single feature, but a synergy of compile-time tools (`if constexpr`, `if consteval`, type traits). Master them for high-performance, type-safe, modern C++ code.