# Chapter 6: Functions and Function Objects  
[Table of Contents](../README.md)
## 6.3: std::function and Invocables

Modern C++ (from C++11 onward) enables a flexible and powerful model for handling *callable* entities—things you can “call” like functions whether or not they are actually functions. The cornerstone of this approach is **std::function**, a type-erasing, general-purpose polymorphic function wrapper that can store anything that’s *invocable* with a specified signature.

This section delves deeply into **std::function**, what counts as an *invocable*, performance trade-offs, best practices, modern alternatives, and real-world use—all in the light of robust, idiomatic, and modern C++.

---

### 1. What is an Invocable?

In C++, an entity is *invocable* if you can use the call syntax on it:

- **Free functions**: `void foo(int);`
- **Member functions**: `struct X { void bar(); };`
- **Function pointers**: `void(*fp)(int)`
- **Lambda expressions**: `auto lambda = [](int x) { return x + 1; };`
- **Functor objects**: Any object with an overloaded `operator()`.

The syntax for all of these is unified: `invocable(args...)`. C++20 introduced the concept **std::invocable** to formally define this idea.

##### Example:

```cpp
#include <iostream>
#include <functional>

void free_function(int x) { std::cout << "free_function: " << x << '\n'; }

struct Functor {
    void operator()(int x) const { std::cout << "Functor: " << x << '\n'; }
};

int main() {
    auto lambda = [](int x) { std::cout << "Lambda: " << x << '\n'; };
    Functor functor;

    free_function(1); // Free function
    lambda(2);        // Lambda
    functor(3);       // Functor
}
```

All three are invocable; they are interchangeable wherever a callable is required.

---

### 2. The Motivation for std::function

Before C++11, flexibility in using invocables was limited primarily to function pointers. This was restrictive:

- Could not store lambdas with captures.
- Could not store functors or member functions generically.
- Poor suitability for higher-order programming (functions taking functions).

**std::function** overcomes this: it can store any copyable invocable with a compatible signature, abstracting the underlying callable behind a unified interface.

##### Example:

```cpp
#include <functional>
#include <vector>
#include <iostream>

void greet() { std::cout << "Hello, world!\n"; }

int main() {
    std::function<void()> fn = greet; // store free function

    fn(); // "Hello, world!"

    auto lambda = [] { std::cout << "Hi from lambda\n"; };
    fn = lambda; // store lambda

    fn(); // "Hi from lambda"

    struct Functor { void operator()() const { std::cout << "Hi from functor\n"; } };
    fn = Functor();

    fn(); // "Hi from functor"
}
```

---

### 3. std::function: Mechanics and API

**std::function<R(Args...)>**

- *Template parameter*: the signature of the function to be stored.
- Can be constructed from any callable invocable with the same signature.
- Type-safe (calls are checked at compile time).
- Supports copy, move, assignment, and can be reset or swapped.

##### Basic Use:

```cpp
std::function<int(int, int)> adder = [](int x, int y) { return x + y; };
std::cout << adder(2, 3); // prints 5
```

##### Checking if it holds a value:

```cpp
std::function<void()> f;
if (!f) {
    std::cout << "f is empty\n";
}
f = [] { std::cout << "Hello\n"; };
if (f) {
    f();
}
```

##### Clearing:

```cpp
f = nullptr; // or f = {}; empties the function wrapper
```

---

### 4. What std::function Can Store

- **Lambdas** (with or without captures)
- **Function pointers**
- **Bind expressions** (`std::bind`)
- **Functor objects** (objects with `operator()`)
- **Member functions** (with some caveats; see below)

#### Member Functions

To store a member function, you need to bind it to an instance:

```cpp
struct MyObj {
    void hello(int x) { std::cout << "Hello: " << x << '\n'; }
};

MyObj obj;

std::function<void(int)> fn = std::bind(&MyObj::hello, &obj, std::placeholders::_1);
// or using a lambda (preferred for readability)
std::function<void(int)> fn2 = [&](int x) { obj.hello(x); };

fn(5);  // "Hello: 5"
fn2(10); // "Hello: 10"
```

#### Lambdas (with or without captures)

Lambdas with captures *cannot* be converted to function pointers, but they *can* be stored in **std::function**:

```cpp
int offset = 3;
std::function<int(int)> add_offset = [offset](int x) { return x + offset; };
std::cout << add_offset(5); // 8
```

---

### 5. Type Erasure and Performance

**Type erasure** allows **std::function** to store any compatible callable, hiding the underlying type (and thus enabling polymorphism). Internally, **std::function** uses dynamic allocation if the stored callable does not fit into a small internal buffer (typically 16–32 bytes, implementation-dependent).

#### Performance considerations:

- **Small Callable Optimization (SCO)**: Most major library implementations avoid heap allocation for small callables.
- **Heap allocation**: If the callable is large (e.g., a lambda that captures large data), storage may be on the heap, incurring performance penalties.
- **Inlined/Direct calls**: A direct call to a lambda or functor is always faster and likely to be inlined by the compiler; **std::function** introduces a layer of indirection (can prevent inlining).
- **Move-only callables**: Pre-C++20, **std::function** requires copyable callables; this changed in C++23, which supports move-only callables (`std::move_only_function`).

##### Best practice:

> - Use **std::function** for interfaces/abstractions or containers of generic callables, where flexibility is needed.
> - Avoid **std::function** in tight inner loops or performance-critical paths; prefer direct invocation or templates to propagate callables via compile-time polymorphism.

---

### 6. Captures, Lifetimes, and Caveats

- **std::function** stores a copy of the callable (including captured state in lambdas).
- Be wary of *dangling references*: if a lambda captured a reference to a local variable, and the containing function returns, the reference may be invalid.
- Use **value captures** or ensure another mechanism for captured lifetimes.

##### Example (dangerous):

```cpp
std::function<void()> fn;
{
    int x = 42;
    fn = [&] { std::cout << x << '\n'; }; // Captures x by reference!
} // x goes out of scope
fn(); // Undefined behavior!
```

##### Corrected (capture by value):

```cpp
std::function<void()> fn;
{
    int x = 42;
    fn = [x] { std::cout << x << '\n'; }; // Captures a copy
}
fn(); // Safe
```

---

### 7. Comparison: std::function vs. Templates (Compile-time vs Runtime Polymorphism)

**std::function** provides *runtime polymorphism*: you can store and invoke different callables through the same type.

**Templates** provide *compile-time polymorphism*: the callable type is determined at compile time, and calls are resolved statically, giving the best performance.

| Feature            | std::function                | Templates                       |
|--------------------|-----------------------------|----------------------------------|
| Type erasure       | Yes                          | No                               |
| Allocation         | Maybe (SCO for small objs)   | None                             |
| Flexibility        | High (mixed callables)       | High (but fixed per instantiation)|
| Performance        | Lower (virtual dispatch)     | Higher (inlined, zero-overhead)  |
| Use case           | APIs, containers, plugins    | Performance, compile-time gen.   |

##### Real-world Example: Passing callables to algorithms

```cpp
// With std::function
void apply_to_all(const std::vector<int>& data, std::function<void(int)> fn) {
    for (int x : data) fn(x);
}

// With template
template <typename Fn>
void apply_to_all(const std::vector<int>& data, Fn&& fn) {
    for (int x : data) fn(x);
}
```

Use templates for high-performance, **std::function** for runtime flexibility (e.g., registering callbacks).

---

### 8. std::function in APIs, Event Systems, and Callbacks

**std::function** is ideal for event-driven or plugin-style code:

##### Example: Registering Callbacks

```cpp
#include <functional>
#include <vector>

class EventDispatcher {
    std::vector<std::function<void(int)>> listeners;
public:
    void add_listener(std::function<void(int)> fn) {
        listeners.push_back(std::move(fn));
    }
    void trigger(int value) {
        for (auto& fn : listeners) fn(value);
    }
};

// Usage:
EventDispatcher dispatcher;
dispatcher.add_listener([](int n){ std::cout << "Event: " << n << '\n'; });
dispatcher.trigger(5); // "Event: 5"
```

Can store lambdas, functions, and functors seamlessly.

---

### 9. Modern Extensions: std::move_only_function (C++23) and std::invocable (C++20)

#### std::move_only_function (C++23)

Allows storage of move-only callables (e.g., non-copyable lambdas):

```cpp
#include <functional>

std::move_only_function<void()> mfn = [ptr = std::make_unique<int>(42)] {
    std::cout << *ptr << '\n';
}; // move-only lambda
```

#### std::invocable (C++20) concept

Allows compile-time checking if a type can be invoked with specified arguments:

```cpp
#include <concepts>

template <std::invocable<int> F>
void do_something(F f) {
    f(42);
}
```

---

### 10. Common Pitfalls and Best Practices

- **Be mindful of captures**: Prefer value-captures unless holding a reference is correct.
- **Don’t use std::function blindly**: For performance-critical code, stick with templates or store callables directly.
- **Minimize allocations**: Store small callables; avoid capturing large resources.
- **Prefer lambdas over std::bind**: Lambdas are clearer and often generate better code.
- **Document callable expectations** in APIs (thread-safety, exception guarantees, etc).

---

### 11. Tools and Real-world Patterns

- **Testing:** Widely used in mock interfaces, test hooks, dependency injection.
- **Signal/Slot libraries**: (e.g., Boost.Signals2, Qt) use **std::function** as the engine for event/callback mechanisms.
- **Concurrency frameworks**: Generic work queue APIs use **std::function<void()>** to store arbitrary tasks.
- **Plugin and architecture patterns**: Loader/registry patterns can use **std::function** for plugin instantiation.

##### Real-world example: Thread pools

```cpp
#include <queue>
#include <functional>
#include <thread>
#include <mutex>
#include <condition_variable>

class ThreadPool {
    std::vector<std::thread> workers;
    std::queue<std::function<void()>> tasks;
    std::mutex mtx;
    std::condition_variable cv;
    bool done = false;

public:
    ThreadPool(size_t n) {
        for (size_t i = 0; i < n; ++i)
            workers.emplace_back([this] {
                while (true) {
                    std::function<void()> task;
                    {
                        std::unique_lock lk(mtx);
                        cv.wait(lk, [&] { return done || !tasks.empty(); });
                        if (done && tasks.empty()) return;
                        task = std::move(tasks.front());
                        tasks.pop();
                    }
                    task();
                }
            });
    }
    void submit(std::function<void()> task) {
        {
            std::lock_guard lk(mtx);
            tasks.push(std::move(task));
        }
        cv.notify_one();
    }
    ~ThreadPool() {
        {
            std::lock_guard lk(mtx);
            done = true;
        }
        cv.notify_all();
        for (auto& t : workers) t.join();
    }
};
```

### 12. Summary Table: Callable Types, Compatibility, and Notes

| Callable                | Can use std::function | Needs workaround | Preferred storage  |
|-------------------------|----------------------|------------------|-------------------|
| Function pointer        | Yes                  | No               | std::function     |
| Lambda (no capture)     | Yes                  | No               | convert to pointer or std::function |
| Lambda (with capture)   | Yes                  | No               | std::function     |
| Functor (operator())    | Yes                  | No               | std::function     |
| Member function pointer | No                   | Yes (bind)       | lambdas           |
| Move-only callable      | Only with C++23      | Yes              | std::move_only_function |

---

## Conclusion: Mastering Function Objects with std::function

A modern C++ programmer should:

- Understand the variety of **invocables** C++ offers and their relationships.
- Use **std::function** to abstract away callable types in APIs, plugins, callbacks, and general purpose polymorphic function storage.
- Prefer templates for high-performance and type-safe compile-time callable usage.
- Take advantage of C++20 concepts like **std::invocable** and new C++23 types such as **std::move_only_function** where appropriate.
- Develop the discipline to analyze performance, capture semantics, and allocation behavior to write robust and efficient code.

By mastering these idioms—complemented by judicious code review and profiling—modern C++ developers can write highly reusable, maintainable, and high-performance code with flexible function objects.