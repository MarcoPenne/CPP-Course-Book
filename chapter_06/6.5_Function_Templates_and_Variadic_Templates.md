# Chapter 6: Functions and Function Objects  
[Table of Contents](../README.md)
## 6.5: Function Templates and Variadic Templates

Modern C++ empowers developers with **powerful abstraction tools** through templates, allowing generic, type-safe, and efficient code. Among those, **function templates** and **variadic templates** are cornerstones for reusable functions, compile-time type safety, and performance without sacrificing expressiveness.

This section explores:
- **Function template syntax, instantiation, and type deduction**
- **Best practices for writing robust generic functions**
- **Understanding variadic templates, `sizeof...`, and parameter pack expansion**
- **Practical, real-world use cases**
- **Common pitfalls and how to avoid them**

---

#### 1. Function Templates: Fundamentals

**Function templates** enable you to write a single function that works with any data type. The compiler generates concrete function versions upon use.

```cpp
template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}
```

- **Syntax:** Use `template <typename T>` or `template <class T>`.
- **Type deduction:** The compiler deduces template parameters based on call arguments.
- **Overload resolution:** Works just like for normal functions, but template instantiation only happens when needed.

**Usage Example:**

```cpp
int result = max(10, 20);            // T deduced as int
double dResult = max(2.5, 3.8);      // T deduced as double
std::string s = max("a"s, "b"s);     // C++14 's' string literal, T is std::string
```

##### Type Deduction and Explicit Specification

Sometimes deduction fails (e.g., differing types), requiring **explicit template arguments**:

```cpp
max<double>(10, 12.5); // Forces T to be double
```

##### Function Template Specialization

**Full specialization** is rare for functions; instead, prefer **overloads** or `if constexpr` (C++17):

```cpp
template<typename T>
bool is_even(T n) {
    if constexpr (std::is_integral_v<T>)
        return n % 2 == 0;
    else
        return false;
}
```

**Best practices:**
- Prefer **if constexpr** over SFINAE for simplicity.
- Use **concepts** (C++20) to constrain types and improve diagnostics.

---

#### 2. Advanced Template Features

##### Non-Type Template Parameters

Templates may accept not only types, but also values known at compile-time, enabling highly efficient code.

```cpp
template <int N>
int factorial() {
    if constexpr (N == 0) return 1;
    else return N * factorial<N - 1>();
}
// Usage: int x = factorial<5>();
```

##### Constrained Templates using Concepts (C++20)

Concepts let you **limit what types** a template will accept:

```cpp
template<typename T>
concept Integral = std::is_integral_v<T>;

template<Integral T>
T gcd(T a, T b) {
    while (b != 0) std::swap(a, b %= a);
    return a;
}
```

---

#### 3. Variadic Templates: Writing Truly Generic Code

Prior to variadic templates (C++11), you needed **overloads or recursive inheritance** for multiple arguments. Now, you can write a function accepting an *arbitrary* number of parameters **with type safety**.

**Syntax:**
```cpp
template<typename... Args>
void print_all(const Args&... args) {
    (std::cout << ... << args) << '\n'; // Fold expression (C++17)
}
```

- `typename... Args` declares a **parameter pack**.
- `args...` expands the pack during instantiation.

##### Classic Example: Recursive Variadic Function

Pre-fold expressions (C++11/14):

```cpp
void print() {} // Base case

template<typename T, typename... Rest>
void print(T first, Rest... rest) {
    std::cout << first << " ";
    print(rest...); // recursive call
}
```

##### Modern Approach: Fold Expressions (C++17)

Fold expressions allow you to expand and operate on all arguments easily:

```cpp
template<typename... Args>
void log(const Args&... args) {
    (std::cout << ... << args) << std::endl; // left fold
}
```

##### Accessing the Number of Arguments

Use `sizeof...(Args)` to discover how many parameters you have:

```cpp
template<typename... Args>
void report_count(const Args&...) {
    std::cout << "Count: " << sizeof...(Args) << '\n';
}
```

##### Passing Parameter Packs to Other Functions

Perfectly forward parameter packs using `std::forward`:

```cpp
template<typename... Args>
void wrapper(Args&&... args) {
    real_function(std::forward<Args>(args)...);
}
```

Always forward parameter packs to preserve value category (lvalue/rvalue).

---

#### 4. Practical and Advanced Applications

##### Variadic Templates in Standard Library

- `std::tuple`, `std::make_tuple`
- `std::apply` (unpacks a tuple to function arguments)
- Variadic constructors (e.g. for containers, forwarding arguments)

**Example: Tuple Construction**
```cpp
auto tup = std::make_tuple(42, 3.14, "C++");
```

##### Universal References ("Perfect Forwarding")

When accepting parameter packs, use `Args&&...` to enable perfect forwarding:

```cpp
template<typename... Args>
void emplace_back(Args&&... args) {
    // Forward to constructor
    container.emplace_back(std::forward<Args>(args)...);
}
```

##### SFINAE versus Concepts

**SFINAE** ("Substitution Failure Is Not An Error") was widely used in pre-C++20 metaprogramming for constraining templates, but **Concepts** offer a clearer, more readable alternative.
Prefer:

```cpp
template<std::integral T>
void process(T t);
```
Over traditional SFINAE incantations.

---

#### 5. Common Pitfalls and Best Practices

- Prefer **type deduction** rather than explicit specification unless necessary.
- Avoid writing template code that is hard to debug. Use **static_assert** and **concepts** to enforce constraints and improve error messages.
- Don't overuse templates: excessive use can complicate code and increase compile times.
- Carefully handle **value categories** (lvalue/rvalue): always forward universal references as shown above.
- Use **`constexpr`**, **`if constexpr`**, and **fold expressions** for more efficient, readable template code.

---

#### 6. Real-world Use Cases

- **Generic Sorting Algorithms:** Write sort routines that work for any swappable/comparable type.
- **Logging Frameworks:** Accept and process arbitrary argument lists.
- **Flexible Factory Functions:** Construct objects forwarding arguments.
- **Event Systems:** Register and handle callbacks with varied signatures.

##### Example: Variadic Logger

```cpp
class Logger {
public:
    template<typename... Args>
    void log(const Args&... args) {
        (std::cout << ... << args) << '\n';
    }
};
Logger logger;
logger.log("Error: ", 404, " at ", "GET /index.html");
```

##### Example: Generic Factory (with Perfect Forwarding)

```cpp
template<typename T, typename... Args>
std::unique_ptr<T> make_object(Args&&... args) {
    return std::make_unique<T>(std::forward<Args>(args)...);
}
auto ptr = make_object<std::vector<int>>(10, 42);
```

---

#### 7. Tools and Further Reading

- **Static analysis:** Modern compilers (`clang`, `gcc`, `MSVC`) and linters warn about template misuse.
- **Debuggers:** Most modern IDEs (Visual Studio, CLion) provide support for step-through and template instantiation analysis.
- **Coverage tools:** Use tests (Catch2, Google Test) to write regression tests for multiple template parameter combinations.

**Recommended books and resources:**
- “Effective Modern C++” by Scott Meyers
- “C++ Templates: The Complete Guide” by Vandevoorde, Josuttis, et al.
- cppreference.com for up-to-date syntax and examples[2][3]
- “Template Metaprogramming with C++” by Marius Bancila[2]
- Modern C++ Core Guidelines (github.com/isocpp/CppCoreGuidelines)

---

A **mastery of function templates and variadic templates** is crucial for modern C++ programming. These techniques make your code base reusable, robust, type-safe — and efficient, leveraging compile-time for performance, while modern features (concepts, fold expressions) promote readability and maintainability.