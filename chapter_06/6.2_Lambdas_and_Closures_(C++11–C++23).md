# Chapter 6: Functions and Function Objects  
[Table of Contents](../README.md)
## 6.2: Lambdas and Closures (C++11–C++23)

**Lambdas**—introduced in C++11—are modern C++'s concise way of defining anonymous function objects (functors) directly in the code. Understanding lambdas is essential for mastering functional patterns, generic code, and expressive algorithms. This subchapter will guide you from the basics to advanced idioms, discuss performance, code quality, and give real-world examples relevant for professional C++ development.

---

### 1. Motivation and Basics

**Why Lambdas?**

- Prior to C++11, function objects required writing explicit classes or using function pointers, leading to verbose and error-prone code.
- **Lambdas offer inline, type-safe, and highly customizable function objects**, perfect for use with STL algorithms and event-driven programming.

**Basic Syntax:**

```cpp
auto sum = [](int a, int b) { return a + b; };
std::cout << sum(3, 4); // Output: 7
```

- `[ ]`           — Lambda introducer, where you capture variables.
- `(int a, int b)`— Parameter list (optional).
- `{ ... }`        — Body.

---

### 2. Capture Lists

Capturing allows lambdas to "remember" variables from their environment.

- **No captures:** `[ ]` (lambda cannot access any external variables.)
- **By value:** `[x]` (copies x.)
- **By reference:** `[&x]` (uses x by reference.)
- **Mixed captures:** `[x, &y]`.
- **Capture all by value:** `[=]`.
- **Capture all by reference:** `[&]`.

Example:

```cpp
int factor = 2;
auto multiply = [factor](int val) { return val * factor; }; // Captures 'factor' by value
factor = 3;
std::cout << multiply(5); // Output: 10 (not 15)
```

For *mutable* state within lambdas, use the `mutable` keyword:

```cpp
int f = 2;
auto m = [f](int x) mutable { f++; return x * f; };
std::cout << m(3); // Output: 9 (f inside lambda is now 3)
```

Best Practice:
- Prefer **value captures** for safety and **reference captures** for performance if you know the lifetime is safe.
- Limit the use of `mutable` unless truly required.

---

### 3. Lambdas in STL Algorithms

**Real-world use**: Most STL algorithms (e.g., `std::sort`, `std::for_each`, `std::transform`) profit from lambdas.

Example: Sorting with custom comparator

```cpp
std::vector<std::string> names {"Alice", "Bob", "Eve"};
std::sort(names.begin(), names.end(), [](const auto& a, const auto& b) {
    return a.size() < b.size();
});
```

**Benefits:**   
- Code locality: Comparator is inline with its usage.
- Type safety: Deduces types automatically.

---

### 4. Advanced Syntax and Features

#### 4.1. Implicit Return Type

The return type can be deduced unless ambiguous:

```cpp
auto doubleVal = [](int x) { return x * 2; }; // Deduces int
```
For complex cases, explicit return type with `->`:

```cpp
auto check = [](int x) -> bool {
    if (x == 42) return true;
    return false;
};
```

#### 4.2. Generic Lambdas (C++14)

Since C++14, you can use `auto` in parameter lists, enabling lambdas to be templates:

```cpp
auto printer = [](auto x) { std::cout << x << "\n"; };
printer("Hello");
printer(123);
```

#### 4.3. Capturing Move-Only Types (C++14/17)

C++14: Using initialization capture—moving objects into lambdas:

```cpp
auto resource = std::make_unique<int>(42);
auto use_resource = [ptr = std::move(resource)]() { std::cout << *ptr; };
```

#### 4.4. Mutable Lambdas

Allows modification of captured-by-value variables in the lambda’s body:
```cpp
auto counter = [n = 0]() mutable { return ++n; };
std::cout << counter(); // 1
std::cout << counter(); // 2
```

#### 4.5. Lambdas in Class Scope

You can use lambdas as member variables or directly within member functions:

```cpp
struct Accumulator {
    int sum = 0;
    void add(int x) {
        auto adder = [this, x]() { sum += x; };
        adder();
    }
};
```

---

### 5. Closures: Lifetime and Implementation

**Closure**: Every lambda is a closure—a callable object that binds captured variables with its code. In C++, lambdas are implemented as unnamed classes with an overloaded operator().

- **Stack captures:** For `[&]` or `[&x]`, be careful about lifetime. Do not return such lambdas if captured objects may go out of scope.
- **Heap captures:** Move-only captures and value captures are safer to return.

Rule:
- Never return a lambda that captures by reference variables that won’t outlive the lambda.

---

### 6. Lambdas and Performance

- **Compiler Optimizations:** Modern compilers optimize lambdas aggressively; lambdas with no captures are usually as efficient as function pointers.
- **Captures and Object Size:** Each captured variable increases the closure’s size. Excessive captures may impact cache and performance—capture minimally.
- **Best Practice:** Use lambdas for short, local logic. For reusable or performance-critical code, consider named function objects or `constexpr` lambdas (C++20).

---

### 7. Lambdas and Asynchrony

C++ lambdas are heavily used in asynchronous programming and concurrency:

```cpp
std::vector<int> nums {1, 2, 3, 4};
std::for_each(std::execution::par, nums.begin(), nums.end(), [](int &x) { x *= 2; });
```

Here, the lambda is used inside a *parallel STL algorithm* (*C++17 and later*).

---

### 8. Lambdas inside Modern APIs and Libraries

Most modern C++ frameworks and libraries (Qt, Boost.Asio, range-v3, modern game engines) encourage lambdas for event handling, callbacks, and pipelines.

Example: **Range-v3**

```cpp
auto even_squares = nums 
  | ranges::views::filter([](int x) { return x % 2 == 0; }) 
  | ranges::views::transform([](int x) { return x * x; });
```

---

### 9. Lambdas and std::function

Lambdas are implicitly convertible to `std::function` if their types are compatible (but beware: conversion incurs type-erasure and heap allocation overhead). If maximal performance matters, avoid storing lambdas in `std::function` unless necessary.

```cpp
std::function<int(int)> f = [](int x) { return x * 2; };
```

---

### 10. New Features in C++20/23

- **constexpr lambdas (C++20):** Lambdas can be `constexpr`, usable at compile time.
- **Template lambdas refinements (C++20):** Parameter packs, concepts.
- **deducing ‘this’ (C++23):** Enables lambdas with explicit object parameters in member functions.
- **Explicit object parameters:** Improves interoperability with ranges and algorithms.

Example:

```cpp
struct S {
    int val;
    auto get_val() const -> int {
        return [self = *this]() { return self.val; }();
    }
};
```

---

### 11. Real World Example: Event Handling

A practical example using lambdas in GUI frameworks:

```cpp
button.onClick([&](int eventId) { 
    std::cout << "Button clicked! Event: " << eventId; 
});
```

Or with resource management:

```cpp
auto file = std::ifstream("data.txt");
auto each_line = [&file](auto func) {
    std::string line;
    while (std::getline(file, line)) func(line);
};

each_line([](const std::string& line) { std::cout << line << '\n'; });
```

---

### 12. Guidelines and Best Practices

- Prefer **lambdas** for short-lived, local logic or when passing functions inline.
- Be careful with **capture semantics**: value is safe, reference is fast (if safe lifetime).
- Use **generic lambdas** for algorithmic code (filtering, transformations).
- Avoid `std::function` if performance is critical—use lambdas directly or named function objects.
- Keep lambdas readable: avoid overly complex or deeply nested lambdas.
- **Document lambdas** if used in non-obvious contexts.

---

### 13. Modern Tools for Lambdas

- **Clang-Tidy**, **cppcheck**, **include-what-you-use** can help refactor lambdas safely.
- IDEs like **CLion** or **Visual Studio** support lambda navigation and debugging.
- Use **unit tests** (Catch2, Google Test) to test higher-order functions and lambdas.

---

### 14. Summary Table: Lambda Features Across C++ Standards

| Feature                              | C++11   | C++14   | C++17   | C++20   | C++23   |
|---------------------------------------|---------|---------|---------|---------|---------|
| Basic lambdas                        | Yes     | Yes     | Yes     | Yes     | Yes     |
| `mutable`                            | Yes     | Yes     | Yes     | Yes     | Yes     |
| Default capture by value/ref          | Yes     | Yes     | Yes     | Yes     | Yes     |
| Generic lambdas (`auto` params)       |         | Yes     | Yes     | Yes     | Yes     |
| Init capture (move)                   |         | Yes     | Yes     | Yes     | Yes     |
| `constexpr` lambdas                   |         |         |         | Yes     | Yes     |
| Concepts, constraints in params       |         |         |         | Yes     | Yes     |
| Deducing `this`/explicit object param |         |         |         |         | Yes     |

---

This overview should help you unlock lambdas from beginner usage to deep mastery, with an emphasis on **best practices, performance, and code quality**, as inspired by Jason Turner's approach and the latest C++ standards. Practice by refactoring legacy functors into lambdas, exploring performance implications in real codebases, and testing idiomatic use with modern tools.