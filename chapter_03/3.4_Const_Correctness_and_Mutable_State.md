# Chapter 3: Fundamental Concepts Revisited
[Table of Contents](../README.md)
## 3.3: Const Correctness and Mutable State

In modern C++, **const correctness** is a foundational concept and best practice that permeates codebases striving for reliability, readability, and optimization. This section explores the philosophy, mechanics, pitfalls, and advanced facets of const-correct coding, interleaving real-world scenarios and deeper insight from modern guidelines.

---

### 1. The Meaning of `const` in C++

At its core, **const** indicates *intent not to modify* a value, and it applies to:

- **Variables**: Declares that a variable cannot be reassigned.
- **Pointers**: Controls what the pointer can point to and/or whether the pointer itself can change.
- **Member Functions**: Guarantees not to modify the state of the object.
- **Function Parameters**: Explicitly signals no modification to arguments.
- **Return Types**: (Rarely) constrains modification of the returned value.

#### Why is this critical?

- **Defensiveness**: Prevents accidental mutation, catching bugs at compile time.
- **Optimization**: Gives compilers room to perform aggressive optimizations.
- **Expressiveness**: Communicates intent for both human readers and tools.
- **APIs**: Enables passing temporaries, const objects, and broader reuse.

---

### 2. Const in Practice

#### 2.1. Basic Use

```cpp
const int max_connections = 100;
```
This variable can never change after initialization.

#### 2.2. Const References and Parameters

Use `const` for parameters that are read-only but expensive to copy:

```cpp
void log_message(const std::string& msg);
```

This prevents accidental modification of the argument and enables binding to temporaries and literals.

##### Best practice:
- Prefer **const references** to avoid unnecessary copies for heavy types like `std::string`, `std::vector`, or user-defined classes.

#### 2.3. Const in Pointers

Syntax can be confusing:

| Declaration                  | Meaning                                                         |
|------------------------------|-----------------------------------------------------------------|
| `const int* ptr`             | Pointer to `const int` (*data* is const, pointer modifiable)    |
| `int* const ptr`             | Const pointer to int (pointer itself is const, data modifiable) |
| `const int* const ptr`       | Const pointer to const int (both const)                         |

```cpp
const int* p1 = &max_connections;  // Can't change *p1
int value = 42;
int* const p2 = &value;            // Can't change p2, but *p2 is modifiable
```

---

### 3. Const Member Functions

Declaring a member function `const` promises *not to modify* the observable state of the object:

```cpp
class Logger {
public:
    std::string prefix;
    std::string get_prefix() const {
        // May not modify any non-mutable member variable.
        return prefix;
    }
};
```

- You **cannot** call non-const methods on a const object.
- A `const` object *restricts* method calls to those labeled `const`.

#### Why?

This enforces real-world contracts—e.g., querying the size of a container does not modify the container:

```cpp
size_t size() const noexcept;
```

##### Compiler enforcement

If `get_prefix()` tried to update `prefix`, the compiler would reject the code.

---

### 4. `mutable`: Controlled Mutability in Const Context

There are legitimate cases where modification is required even inside `const` methods (e.g., caching, statistics). The `mutable` keyword allows specific members to be modifiable even when part of a `const` object.

```cpp
class FactorialCache {
    mutable std::map<int, int> cache;
public:
    int compute(int x) const {
        auto it = cache.find(x);
        if (it != cache.end())
            return it->second;
        int result = ...; // compute factorial
        cache[x] = result; // <-- allowed due to 'mutable'
        return result;
    }
};
```
**Use of `mutable` must be justified**: Prefer it only for logically "invisible" side effects (like caching or lazy loading), not state mutation that changes object semantics.

---

### 5. Const Correctness in APIs and Design

#### - Pass by Value or by Const Reference?
  - **Small types** (e.g., `int`, `double`, `char`) by value.
  - **Large objects** by `const &`.

#### - Return by Value vs. by Reference

Modern compilers optimize well (e.g., copy elision). Use return by value for small/lightweight objects; use `const &` only when returning references to existing objects, never to temporaries.

#### - Const Iterator

Const-correct containers expose **const iterators** to prevent modification:

```cpp
std::vector<int> v = {1, 2, 3};
for (auto it = v.cbegin(); it != v.cend(); ++it)
    std::cout << *it << '\n';  // *it is const int&
```

From C++11, `auto` deduces iterator type; use `const auto&` when iterating over values you don't want to modify:

```cpp
for (const auto& value : v)
    std::cout << value << '\n'; // value is const int&
```

---

### 6. Deep Const: Pointer and Container Members

`const` prohibits modifying the value of a pointer or reference member, but **not the mutability of the pointee**. This distinction is crucial for classes that manage buffers or containers:

```cpp
class Buffer {
    std::unique_ptr<char[]> data;
public:
    // This function can't reassign `data`, but can mutate the bytes:
    void fill(char c) const {
        std::fill(data.get(), data.get() + size, c);  // This compiles!
    }
};
```

Const-correctness often requires entire API contracts and ownership semantics to be clear—consider **ownership models** with smart pointers and immutability.

---

### 7. Constexpr, Constinit, and Immutable State

#### - `constexpr`: Enforces value computation at compile time.

```cpp
constexpr int pow(int base, int exp) {
    return exp == 0 ? 1 : base * pow(base, exp - 1);
}
constexpr int sixteen = pow(2, 4); // Evaluated at compile time
```

#### - `constinit` (C++20): Ensures that variable is initialized at compile time, but not necessarily constant after.

```cpp
constinit int config_flag = 1; // Can be changed at runtime later
```

Both keywords enable **compile-time state safety** and can boost performance by pushing computation out of runtime.

---

### 8. Avoiding Common Const Pitfalls

- **Dangling References**: Never return a `const &` to a local (it will dangle).
- **Shallow Const**: `const std::vector<int>*` forbids changing the vector itself (e.g., no push_back), but the `int` values can still be modified.
- **Casts and `const_cast`**: Avoid unless interfacing with legacy code or C APIs, and only as a last resort.

```cpp
void dangerous(const int* p) {
    int* q = const_cast<int*>(p); // potentially undefined behavior!
}
```

---

### 9. Real-World Patterns and Best Practices

- **Immutability**: Favor immutable data for thread safety and simplicity. Use `const` wherever possible and prefer pure functions (no side effects).

- **Avoid “const” Madness**: Overuse (like “const” on *every* parameter, even ints and chars) adds noise; use judiciously, guided by intent and performance.

- **Thread Safety**: Immutability via `const` inherently makes code safer in concurrent contexts.

- **Testing and Tooling**: Leverage static analysis tools (clang-tidy, cppcheck) to flag non-const-correct code for early intervention.

---

### 10. Modern C++ and Const-Correctness Enhancements

From C++11 onwards, features like:

- **Range-based for-loops** (`for (const auto& x : xs)`)
- **`constexpr` functions and variables**
- **Type deduction**: `auto` works seamlessly with `const`
- **Smart pointers**: Support for const-correct resource management

These features make const-correctness easier and more natural; it's easier than ever to write APIs that respect immutability.

---

### Example: Const Correctness in a Class API

```cpp
class SensorData {
    std::vector<double> readings_;
public:
    void add_reading(double r) { readings_.push_back(r); }

    std::vector<double> get_readings() const { return readings_; } // by value: safe, but makes a copy

    const std::vector<double>& get_readings_ref() const { return readings_; } // allows read-only (beware: caller can still mutate the referred-to vector via non-const pointer/reference)

    double mean() const {
        double sum = std::accumulate(readings_.begin(), readings_.end(), 0.0);
        return readings_.empty() ? 0.0 : sum / readings_.size();
    }
};
```

Use `const` consistently to signal which methods are readonly and which mutate state.

---

### Advanced: Constexpr and Functional Immutability

Modern C++ encourages functional paradigms; favor *stateless* or *immutable* objects where practical.

```cpp
struct Point {
    double x, y;
    constexpr Point move(double dx, double dy) const { return Point{x + dx, y + dy}; }
};

constexpr Point origin{0, 0};
constexpr Point moved = origin.move(1, 2); // Evaluated at compile-time
```

---

### Conclusion

**Const correctness** is not boilerplate: it asserts intent, boosts safety, unlocks optimization, and improves clarity. Mastery of `const`, delicate use of `mutable`, and an appreciation of modern best practices are hallmarks of advanced C++ programmers. Embrace `const` as a communication tool—for the compiler, for your colleagues, and for your future self.