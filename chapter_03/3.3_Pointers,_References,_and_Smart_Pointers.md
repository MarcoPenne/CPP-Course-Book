# Chapter 3: Fundamental Concepts Revisited
[Table of Contents](../README.md)
## 3.3: Pointers, References, and Smart Pointers

Pointers and references are core C++ features that allow you to build flexible, efficient, and safe software. Modern C++—from C++11 onward—has gradually modernized these concepts, especially with new smart pointer types and lifetime management features. Mastering pointers, references, and smart pointers is essential for writing robust, expressive code and for understanding the language’s deeper mechanics.

---

### 1. **Pointers**

#### What is a Pointer?

A **pointer** is a variable that stores the memory address of another object or function. The value of a pointer can be changed to point to different objects, or it can be null (pointing to nothing).

```cpp
int x = 42;
int* p = &x; // p points to x
```

**Key characteristics:**
- Type information: A pointer has a type (e.g., `int*`, `double*`); you cannot, for example, assign a `double*` to an `int*` without an explicit cast.
- Can be reassigned or set to `nullptr`.
- Supports arithmetic (dangerous and discouraged unless working with arrays or low-level code).

#### Pointer Dereferencing

You access the object a pointer points to via the dereference operator (`*`):

```cpp
int value = *p; // gets 42
*p = 17;        // sets x to 17
```

**Best Practices:**
- Always initialize pointers.
- When a pointer doesn’t point to a valid object, set it to `nullptr` (since C++11).

```cpp
int* q = nullptr;
```

- Pointer arithmetic is only safe within arrays or container bounds.

#### Null Pointers and `nullptr`

C++11 introduced `nullptr`, a type-safe null pointer constant. Prefer `nullptr` over `NULL` or `0` for clarity and type safety.

```cpp
if (p == nullptr) { /* pointer is not pointing to any object */ }
```

#### Pointer Types

- **Raw pointers:** Unmanaged, require explicit memory allocation and deallocation.
- **Function pointers:** Can store addresses of functions.
  
    ```cpp
    void (*func)() = &foo;
    ```
- **Member pointers:** For accessing members in classes.

#### Dynamic Memory Management

Allocating and releasing memory explicitly:

```cpp
int* arr = new int[10];
// ... use arr
delete[] arr;
```
- Always ensure every `new` matches a `delete`, and every `new[]` matches a `delete[]`.
- Use **smart pointers** (see below) instead of raw pointers wherever possible.

---

### 2. **References**

#### What is a Reference?

A **reference** is an alias for another variable. Once initialized, a reference cannot be reseated to another object.

```cpp
int x = 5;
int& ref = x; // ref is another name for x
ref = 42;     // sets x to 42
```

#### Key Rules

- References must always refer to a valid object; they **cannot be null** or uninitialized.
- There are two important types:
  - **Lvalue references** (`T&`)
  - **Rvalue references** (`T&&`) (since C++11)

#### Lvalue references

- Bind to named objects (lvalues).
- Used for function parameters or return values when you want to allow modification or to avoid copying:

    ```cpp
    void increment(int& n) {
        ++n;
    }
    ```

#### Rvalue references

- Bind to temporaries and objects that can be “moved from”.
- Enable move semantics (see move semantics and smart pointers).

    ```cpp
    void setValue(std::string&& s);
    ```

#### Reference Collapsing

Complex template code involves *reference collapsing* rules:

- `T& &` becomes `T&`
- `T&& &` and `T& &&` both become `T&`
- `T&& &&` becomes `T&&`

This underlies *perfect forwarding* and universal references in template code, allowing efficient function parameter passing.

#### When to Use References

- Always prefer references for non-nullable, non-reseatable aliasing.
- Use `const T&` for function parameters to avoid unnecessary copying of complex objects:

    ```cpp
    void printName(const std::string& name);
    ```

---

### 3. **Smart Pointers**

Manual memory management with raw pointers is error-prone and a common source of bugs: **leaks**, **dangling pointers**, and **double deletes**. Modern C++ offers *smart pointers* in `<memory>` as safer, expressive alternatives[2].

#### 3.1. Unique Ownership: `std::unique_ptr`

A `std::unique_ptr<T>` owns a dynamically allocated object, enforcing *single ownership* semantics:

- Cannot be copied, only moved.
- Automatically deletes the owned object when the `unique_ptr` goes out of scope.
- Useful for managing resources within a scope or move-only objects (e.g., a file handle).

```cpp
#include <memory>

std::unique_ptr<MyClass> ptr = std::make_unique<MyClass>();
// ptr goes out of scope: deletes MyClass automatically

void takeOwnership(std::unique_ptr<MyClass> p) { /* ... */ }
takeOwnership(std::move(ptr)); // ownership transferred
```

**Best practices:**
- Prefer `std::make_unique<T>(...)` (C++14+) over direct use of `new`.
- Use for exclusive ownership and as members of RAII classes.

#### 3.2. Shared Ownership: `std::shared_ptr`

A `std::shared_ptr<T>` tracks *shared ownership* of a dynamically allocated object by keeping a reference count. The object is deleted when the last `shared_ptr` owning it is destroyed.

```cpp
#include <memory>

auto sp1 = std::make_shared<MyClass>();
auto sp2 = sp1; // both pointers share ownership
```

**Best practices:**
- Prefer `std::make_shared<T>(...)` for efficiency and exception safety.
- Use only when shared ownership is required. Overuse can lead to *cyclic references* and thus memory leaks.

##### Cyclic References and `std::weak_ptr`

If two `shared_ptr` instances reference each other (cycle), they will never be destroyed. Use `std::weak_ptr` as a non-owning reference to break cycles:

```cpp
struct Node {
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> prev; // weak_ptr breaks the cycle
};
```

#### 3.3. Custom Deleters

Both `unique_ptr` and `shared_ptr` can use custom deleters for advanced resource management (e.g., releasing OS handles):

```cpp
auto fileCloser = [](FILE* f) { if (f) fclose(f); };
std::unique_ptr<FILE, decltype(fileCloser)> filePtr(fopen("file.txt", "r"), fileCloser);
```

#### 3.4. Comparison Table

| Pointer Type        | Ownership   | Nullable | Moveable | Copyable | Best Use                                   |
|---------------------|-------------|----------|----------|----------|--------------------------------------------|
| Raw Pointer         | None        | Yes      | Yes      | Yes      | Low-level code, APIs, legacy interfaces    |
| `std::unique_ptr`   | Unique      | Yes      | Yes      | No       | Exclusive ownership, RAII, resource safety |
| `std::shared_ptr`   | Shared      | Yes      | Yes      | Yes      | Shared ownership, as required              |
| `std::weak_ptr`     | None        | Yes      | Yes      | Yes      | Observing shared ownership, breaking cycles|
| Reference (`T&`)    | None        | No       | No       | N/A      | Persists through object lifetime           |

---

### 4. **Best Practices and Modern Style**

- **Favor smart pointers over raw pointers** in application code. Use raw pointers for non-owning, transient references when clarity and performance dictate.
- **Avoid `new` and `delete` in modern C++**, except in performance-critical, low-level, or memory pool code.
- **Always use RAII** (Resource Acquisition Is Initialization): tie resource management to object lifetime.
- **Be explicit with ownership**: code reviews should always clarify who is responsible for resource cleanup.
- For **interfacing with legacy code**, wrap raw pointers in smart pointers as soon as possible.

---

### 5. **Real-World Example: Resource Ownership in Modern C++**

Suppose you want to manage a graphics resource that should be unique, and sometimes hand off ownership to a renderer class.

```cpp
class Texture {
    // ... load and manage GPU texture ...
};

void loadAndDisplay() {
    std::unique_ptr<Texture> tex = std::make_unique<Texture>("img.png");
    renderer.setTexture(std::move(tex)); // transfers ownership to renderer
}
```

If multiple rendering components need to share read-only access:

```cpp
auto mesh = std::make_shared<Mesh>(...);
renderer.setMesh(mesh);
collisionSystem.setMesh(mesh);
// mesh will be destroyed when both are done
```

---

### 6. **Common Pitfalls and Advanced Notes**

- **Dangling references/pointers:** Storing references/pointers to local variables is undefined behavior.
- **Object slicing:** Be careful when using references or pointers to base classes.
- **Don’t use smart pointers for all objects:** Stack-scoped variables are always preferred when no dynamic lifetime management is required.
- **std::weak_ptr::lock():** Always check if the pointer is valid before using it. 

---

### 7. **Conclusion & Further Reading**

The careful and idiomatic use of **pointers, references, and smart pointers** is critical for writing modern, safe, and fast C++. Adhering to the principles and best practices explained here helps eliminate a whole category of bugs, especially around resource management and memory safety.

For deeper dives and more patterns, consult these authoritative C++ resources:

- *Beautiful C++* by Davidson & Gregory – for quality and idiomatic code[2].
- *The C++ Programming Language* by Bjarne Stroustrup.
- Google C++ Style Guide—detailed best practices and pitfalls[4].
- C++ Core Guidelines (edited by Herb Sutter, others).

By understanding and practicing these tools and idioms, you will write more robust, efficient, and modern C++ code.