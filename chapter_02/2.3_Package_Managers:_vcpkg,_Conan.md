# Chapter 2: Getting Started and Essential Tools
[Table of Contents](../README.md)
## 2.3: Package Managers: vcpkg, Conan

Modern C++ development has increasingly adopted **package managers** to simplify dependency management, enable rapid prototyping, and improve reproducibility across varied platforms. Unlike languages such as Python (pip), JavaScript (npm), or Rust (cargo), C++ was long notorious for lacking ubiquitous, robust package management. With tools like **vcpkg** and **Conan**, developers can now efficiently integrate, manage, and update third-party libraries within their projects, making C++ as agile as any other modern language ecosystem.

This section explains core package manager concepts, usage patterns, real-world scenarios, and best practices for using vcpkg and Conan—equipping readers to master **dependency management** in contemporary C++.

---

### Why Package Management Matters

**Manual dependency management** in C++ traditionally involved:

- Downloading source archives or precompiled binaries.
- Manually tracking versions, build flags, and compatibility.
- Handling cross-platform builds and tooling differences.

Such approaches are error-prone, risk version conflicts (“dependency hell”), complicate CI/CD, and significantly slow development. A package manager automates:

- Fetching, configuring, and building dependencies.
- Keeping versions in sync.
- Integrating with build systems (CMake, Meson, etc.).
- Promoting reproducible builds and easier onboarding.

---

### Overview: vcpkg and Conan

| Feature                | vcpkg                         | Conan                              |
|------------------------|-------------------------------|------------------------------------|
| **Origin**             | Microsoft                     | JFrog (Open Source)                |
| **Primary Use Case**   | System-level global packages  | Per-project package environments   |
| **Platform Support**   | Windows, Linux, MacOS         | Windows, Linux, MacOS, embedded    |
| **Integration**        | Tight with Visual Studio/CMake| CMake, Autotools, Meson, more      |
| **Package Database**   | 2000+ curated packages        | Central registry + custom remotes  |
| **Customization**      | Basic configuration           | Advanced: profiles, build options  |
| **Binary vs Source**   | Mostly builds from source     | Both source and binary cache       |

---

### vcpkg

**vcpkg** is a cross-platform, open-source C++ library manager from Microsoft. It is widely recommended for its deep integration into Visual Studio, CMake, and for providing curated ports of popular C++ libraries.

#### Installing vcpkg

```bash
git clone https://github.com/microsoft/vcpkg.git
cd vcpkg
./bootstrap-vcpkg.sh  # Linux/MacOS
.\bootstrap-vcpkg.bat # Windows
```

You typically add vcpkg to your system `PATH` or invoke it directly in your project setup.

#### Adding Packages

vcpkg maintains a catalog; to install (for example) **fmt** and **boost**:

```bash
./vcpkg install fmt boost
```

Packages (headers, libraries) are built and installed into a root (`vcpkg/installed/x64-linux`, etc.).

#### Integrating with CMake

To make CMake projects automatically use vcpkg libraries:

```bash
./vcpkg integrate install
```

This configures CMake toolchain files so `find_package(fmt)` now works out of the box.

**Example: Using fmt Library via vcpkg**

In your `CMakeLists.txt`:

```cmake
find_package(fmt CONFIG REQUIRED)
target_link_libraries(MyApp PRIVATE fmt::fmt)
```

In your code:

```cpp
#include <fmt/core.h>
#include <iostream>

int main() {
    std::cout << fmt::format("Hello, {}!", "World") << std::endl;
}
```

##### Best Practices with vcpkg

- **Lock versions** for reproducibility (manifest mode, see below).
- Use **CMake toolchain files** for full integration.
- Prefer the **manifest mode** for per-project configuration.

**Manifest Mode Example:**

Create a `vcpkg.json` file:

```json
{
  "name": "my-cpp-project",
  "version": "1.0.0",
  "dependencies": [
    "fmt",
    "boost"
  ]
}
```

This is analogous to package manifests in other languages and promotes portable development.

---

### Conan

**Conan** is a professional-grade, multi-platform package manager suited for more advanced workflows: custom build options, versioning, cross-compilation, and private registries. It is used by startups and major embedded/system software organizations.

#### Installing Conan

```bash
pip install conan
```
Requires Python 3.

#### Creating and Consuming a Project

Start with:

```bash
conan new hello/0.1 -m
```
Generates a new package template.

#### Adding Dependencies (Conanfile)

You define dependencies in a `conanfile.txt` or `conanfile.py`:

**conanfile.txt:**

```ini
[requires]
fmt/9.1.0
boost/1.83.0

[generators]
CMakeToolchain
CMakeDeps
```

#### Installing Packages

Install dependencies locally:

```bash
conan install . --output-folder=build --build=missing
```

Conan will resolve correct binaries for your platform/configuration and generate platform-aware build configuration files.

#### Integration with CMake

Inside your `CMakeLists.txt`, leverage auto-generated files:

```cmake
include(${CMAKE_BINARY_DIR}/conan_toolchain.cmake)
```

Find packages using Conan's configs:

```cmake
find_package(fmt)
find_package(Boost)
```

##### Advanced Features of Conan

- **Profiles:** Set compiler, OS, build settings for reproducible environments.
- **Remotes:** Use or configure custom package repositories (enterprise, private, open-source).
- **Options and Variants:** Fine-grained control of how dependencies are built (shared/static, feature toggles).
- **Binary Caching:** Prevents unnecessary recompilation when switching platforms or settings.
- **Custom Packages:** Easily create and publish internal libraries as managed Conan packages.

#### Example: Using a Third-Party Library (spdlog) via Conan

**conanfile.txt:**

```ini
[requires]
spdlog/1.11.0

[generators]
CMakeToolchain
CMakeDeps
```

**CMakeLists.txt:**

```cmake
find_package(spdlog REQUIRED)
target_link_libraries(MyApp PRIVATE spdlog::spdlog)
```

**main.cpp:**

```cpp
#include <spdlog/spdlog.h>

int main() {
    spdlog::info("Welcome to {}!", "Modern C++ with Conan");
}
```

---

### Real-World Scenarios and Best Practices

- **CI/CD Integration:** Package managers are indispensable for continuous integration (CI), enabling fully scripted, reproducible builds—even across ephemeral containers or diverse OSes.
- **Cross-compilation:** Easily manage dependencies for multiple target architectures (ARM, x86, embedded) without manual intervention.
- **Team Onboarding:** New developers can clone a repo and, after a single command, build the project and its dependencies without manual configuration.

#### Common Pitfalls

- **ABI Incompatibility:** Some binary packages may be incompatible across different compilers or flags. Prefer source builds with identical toolchains unless the package manager guarantees ABI compatibility.
- **License Compliance:** Automated package fetches don’t absolve due diligence. Check license terms of all libraries.
- **Dependency Upgrades:** Automated upgrades are easy—but test code for behavioral changes and regressions.

---

### Summary Table: vcpkg vs. Conan—When to Use Which

| Situation                        | Prefer vcpkg                             | Prefer Conan                         |
|-----------------------------------|------------------------------------------|--------------------------------------|
| Windows/CMake/Visual Studio team  | Yes                                      | Possible, but vcpkg is faster        |
| Mixed-platform, multiplatform     | Yes                                      | Yes                                  |
| Custom build variants/profiles    | Basic support                            | Advanced support                     |
| Private/internal packages         | Basic support (fork, local ports)        | Excellent support (remotes, upload)  |
| Rapid onboarding/simple project   | Yes                                      | Yes                                  |
| Complex enterprise CI/CD          | Yes                                      | Yes + advanced integration           |
| Source builds of all dependencies | Yes                                      | Yes                                  |
| Using binary caches               | No (limited)                             | Yes                                  |

---

### Modern C++ Ecosystem: Package Management in Practice

Whether starting with vcpkg or moving to Conan for advanced needs, **mastery of package managers** is now essential for every serious C++ developer. These tools eliminate tedious manual work, allow you to focus on problem-solving and code quality, and ensure your projects are robust, reproducible, and scalable.

For further practice, clone a modern open-source C++ project that uses vcpkg or Conan, examine its manifest and build setup, and experiment by adding/removing dependencies or switching between package manager modes. This hands-on experience will make any C++ developer ready for real-world challenges and cross-platform delivery.

---

**Key takeaway:** Adopt and deeply understand vcpkg and Conan as part of your modern C++ toolkit to unlock productivity, code quality, and professionalism in all your projects.